/*

Generic Group 
            
see also root.h

replaces vsr_pointGroup.h (eventuallY)

*/
  
                     
#include "vsr_set.h" 
#include "vsr_root.h"
#include "vsr_generic_op.h"
#include <vector>                 
 
using std::vector;

namespace vsr{

/// V are versors any dimension, etc DualLines in cga2D or DualPlanes in cga3D
template< class V >
struct Group {

   bool bPin; //Spin or Pin

   vector<V> ops;

   Group(bool p = true) : bPin(p) {}
   Group( vector<V> v, bool p = true ) : ops(v), bPin(p) {}

    /* //Calculates all permuations of group and sets group to it */
    /* void calc(){ */
    /*   auto t = Root::System( ops ); */
    /*   ops = t */
    /* } */

    /// Enacts All operators on p (sequentially)?, returns p and all results
	  template<class T>
    vector<T> operator()(const T& p){
        vector<T> res; //res.push_back(p);
        T tp = p; 
        for (auto i : ops ){
          tp = bPin ? p.re( i ) : p.sp( i ) ;
          res.push_back( tp ); // Reflect or Spin in each member of the group
        }       
        return res;
    }

}; 

/// ND lattice, on a metric specified by V's type.  Not a group, but a group can be made from it
template< int DIM, class V >
struct Lattice {

    static const int Dim = DIM;

    //GET VEC "B" TYPE OF TYPE V's AMBIENT METRIC ("MODE")
    typedef typename V::template BType< typename V::Mode::Vec > Vec;
    typedef typename V::template BType< typename V::Mode::Biv > Biv;

    Vec vec[ DIM ];

    Vec& operator[](int idx) { return vec[idx]; }
    Vec operator[](int idx) const { return vec[idx]; }

    Vec at() { return Vec(); }

    template<class ... T>
    Vec at( int x, T...v ){
        int idx = DIM - ( sizeof...(v) + 1 );
        return vec[idx] * x + at(v...);
    }

    /// END case
    void set(){}
    /// Recursively set each idx 
    template<class ... T>
    void set(int x, T ... xs){
      using TE = typename V::template BType< typename V::Mode::template e< ( DIM - ( sizeof...(T) )) > >;
      int idx = DIM - ( sizeof...(T) + 1);
      Biv biv = V::x ^ TE(1);
      vec[idx] = V::x.rot( biv * PIOVERTWO/x );

      set(xs...);
    }
    
    /// Feed in a list of ratios 
    template<class ... T>
     Lattice(int x, T ... xs) {
        vec[0] = V::x;
        set(x,xs...);      
    }

};
    

//A 2d point group at the origin . . . 
//////V is the reflection type of the point group (dll or dlp)

template< class V > 
struct PointGroup2D : Group< V > {
  
    typedef decltype( V() ^ V() ) Biv;

    V a, b;                 ///< Generators

    PointGroup2D(int p) {
       a = V::x;
       b = V::x.rot( Biv::xy * PIOVERTWO/p );
       this->ops = Root::System(a,b);
    }

};


//a pointgroup + a lattice, here we assume the conformal model is in play (2D or above)
template<class V > 
struct SpaceGroup2D : PointGroup2D<V> {

  /// Trs is the translator type of whatever conformal metric we are in
  typedef typename V::template BType< typename V::Mode::Trs > Trs; 
 
  /// 2D SpaceGroups have two translators generated by the lattice 
  Trs ta, tb;
      
  SpaceGroup2D(int p) : PointGroup2D<V>(p)  {
    ta = Gen::trs ( this->a );
    tb = Gen::trs ( this->b );
  }

    Trs trs( int x, int y ) {
       return Gen::trs( this->a * x +  this->b * y  );
    }

    Group<V> at(int x, int y) {
      
      vector<V> res;
      
      for (auto i : this->ops ) res.push_back( i.spin(trs(x,y) ) );
      return res;
  }

};

template<class V>
struct PointGroup3D : Group< V > {

    typedef typename V::template BType< typename V::Mode::Biv > Biv;
    //typedef typename V::template BType< typename V::Mode::Mot > Mot;

    V a, b, c;

    //must satisfy dicycle ab^p = bc^q = ac^2
    PointGroup3D(int p, int q) {
      a = V::x;
      Biv biv = Biv::xy * PIOVERTWO / p;
      Biv biv2 = Biv::yz * PIOVERTWO / q;
      b = V::x.rot(biv).rot(biv2);
      c = V::y;// b.rot( biv2 );
      this->ops = Root::System(a,b,c);
    }

    auto ab() RETURNS ( a * b )
    auto ac() RETURNS ( a * c )
    auto bc() RETURNS ( b * c )

};

template<class V>
struct SpaceGroup3D : PointGroup3D<V> {

    typedef typename V::template BType< typename V::Mode::Trs > Trs; 

    Trs ta, tb, tc;

    SpaceGroup3D(int p, int q) : PointGroup3D<V>(p,q){
        ta = Gen::trs( this->a);
        tb = Gen::trs( this->b);
        tc = Gen::trs( this->c);
    }

    Trs trs( int x, int y, int z ) {
       return Gen::trs( this->a * x +  this->b * y + this->c*z );
    }

    Group<V> at(int x, int y, int z){
      vector<V> res;
      for (auto i : this->ops) res.push_back( i.spin( trs(x,y,z) ) );
      return res;
    }


};




//A-n (see also tetra / ortho)        
template<TT DIM>
class Simplex{
	
	typedef EGAMV< DIM, typename EGA<DIM>::Vec > Root;
	
	
	
};  

template<>
class Simplex<2>{
	typedef EGAMV< 2, typename EGA<2>::Vec > Root; 
	 
	
};

} //vsr::
